import React, { useState, useMemo, useEffect } from 'react';
import { ungzip } from 'pako';
import { toUint8Array } from 'js-base64';
import { encodeAbiParameters, pad, isHex, sliceHex, keccak256, toHex, toBytes as toBytes$1 } from 'viem';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$1 = ".sismoConnectButton {\n    color: #FFFFFF;\n    background: #1C2847;\n    border: 1px solid #3F4973;\n    border-radius: 10px;\n    padding: 15px 25px;\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    cursor: pointer;\n}\n\n.sismoConnectButtonText {\n    font-weight: 400;\n    font-size: 18px;\n}\n\n.sismoConnectButtonLogo {\n    height: 16px;\n    width: 16px;\n}";
styleInject(css_248z$1);

var Logo = function () {
    return (React.createElement("svg", { width: "16", height: "17", viewBox: "0 0 16 17", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("path", { d: "M7.99994 15.75L15.6234 10.2115L12.7113 1.25H3.28855L0.376465 10.2115L7.99994 15.75Z", fill: "url(#paint0_linear_123_4882)" }),
        React.createElement("path", { d: "M7.99994 15.75L15.6234 10.2115M7.99994 15.75L0.376465 10.2115M7.99994 15.75L13.4088 9.89149M7.99994 15.75L2.6347 9.89149M15.6234 10.2115L12.7113 1.25M15.6234 10.2115L13.4088 9.89149M12.7113 1.25H3.28855M12.7113 1.25L13.4088 9.89149M3.28855 1.25L0.376465 10.2115M3.28855 1.25L13.4088 9.89149M3.28855 1.25L2.6347 9.89149M0.376465 10.2115L2.6347 9.89149", stroke: "url(#paint1_linear_123_4882)", strokeWidth: "0.5", strokeMiterlimit: "10" }),
        React.createElement("defs", null,
            React.createElement("linearGradient", { id: "paint0_linear_123_4882", x1: "3.5", y1: "1.5", x2: "11.75", y2: "13.25", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { offset: "0.0876413", stopColor: "#0F1D42" }),
                React.createElement("stop", { offset: "0.55703", stopColor: "#877C6A" }),
                React.createElement("stop", { offset: "0.914377", stopColor: "#E2C488" })),
            React.createElement("linearGradient", { id: "paint1_linear_123_4882", x1: "3.5", y1: "1", x2: "11.75", y2: "13.25", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", { stopColor: "#E2C488" }),
                React.createElement("stop", { offset: "1", stopColor: "#13203D" })))));
};

var css_248z = ".sismoConnectButtonLoader {\n    width: 16px;\n    height: 16px;\n    border: 2px solid #FFF;\n    border-bottom-color: transparent;\n    border-radius: 50%;\n    display: inline-block;\n    box-sizing: border-box;\n    animation: rotation 1s linear infinite;\n}\n\n@keyframes rotation {\n    0% {\n        transform: rotate(0deg);\n    }\n    100% {\n        transform: rotate(360deg);\n    }\n} ";
styleInject(css_248z);

var Loader = function () {
    return React.createElement("div", { className: "sismoConnectButtonLoader" });
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var SISMO_CONNECT_VERSION = "sismo-connect-v1";
var ProvingScheme;
(function (ProvingScheme) {
    ProvingScheme["HYDRA_S2"] = "hydra-s2.1";
})(ProvingScheme || (ProvingScheme = {}));
var ClaimType;
(function (ClaimType) {
    ClaimType[ClaimType["GTE"] = 0] = "GTE";
    ClaimType[ClaimType["GT"] = 1] = "GT";
    ClaimType[ClaimType["EQ"] = 2] = "EQ";
    ClaimType[ClaimType["LT"] = 3] = "LT";
    ClaimType[ClaimType["LTE"] = 4] = "LTE";
})(ClaimType || (ClaimType = {}));
var AuthType;
(function (AuthType) {
    AuthType[AuthType["VAULT"] = 0] = "VAULT";
    AuthType[AuthType["GITHUB"] = 1] = "GITHUB";
    AuthType[AuthType["TWITTER"] = 2] = "TWITTER";
    AuthType[AuthType["EVM_ACCOUNT"] = 3] = "EVM_ACCOUNT";
})(AuthType || (AuthType = {}));
var SismoConnectVerifiedResult = /** @class */ (function () {
    function SismoConnectVerifiedResult(_a) {
        var response = _a.response, claims = _a.claims, auths = _a.auths;
        this.response = response;
        this.claims = claims;
        this.auths = auths;
        this.signedMessage = response.signedMessage;
    }
    SismoConnectVerifiedResult.prototype.getUserId = function (authType) {
        var _a;
        var userId = (_a = this.auths.find(function (verifiedAuth) { return verifiedAuth.authType === authType; })) === null || _a === void 0 ? void 0 : _a.userId;
        return resolveSismoIdentifier(userId, authType);
    };
    SismoConnectVerifiedResult.prototype.getUserIds = function (authType) {
        return this.auths.filter(function (verifiedAuth) { return verifiedAuth.authType === authType && verifiedAuth.userId; }).map(function (auth) { return resolveSismoIdentifier(auth.userId, authType); });
    };
    SismoConnectVerifiedResult.prototype.getSignedMessage = function () {
        return this.signedMessage;
    };
    return SismoConnectVerifiedResult;
}());
var startsWithHexadecimal = function (str) {
    var hexRegex = /^0x[0-9a-fA-F]{6}/;
    return hexRegex.test(str);
};
var resolveSismoIdentifier = function (sismoIdentifier, authType) {
    if (authType === AuthType.EVM_ACCOUNT || authType === AuthType.VAULT)
        return sismoIdentifier;
    if (!startsWithHexadecimal(sismoIdentifier))
        return sismoIdentifier;
    var removeLeadingZeros = function (str) {
        var arr = str.split("");
        while (arr.length > 1 && arr[0] === "0") {
            arr.shift();
        }
        return arr.join("");
    };
    sismoIdentifier = sismoIdentifier.substring(6);
    sismoIdentifier = removeLeadingZeros(sismoIdentifier);
    return sismoIdentifier;
};
var toSismoIdentifier = function (identifier, authType) {
    if (authType === AuthType.EVM_ACCOUNT || authType === AuthType.VAULT)
        return identifier;
    if (startsWithHexadecimal(identifier))
        return identifier;
    var prefix = "";
    if (authType === AuthType.GITHUB) {
        prefix = "0x1001";
    }
    if (authType === AuthType.TWITTER) {
        prefix = "0x1002";
    }
    identifier = "0".repeat(36 - identifier.length) + identifier;
    identifier = prefix + identifier;
    return identifier;
};
var RequestBuilder = /** @class */ (function () {
    function RequestBuilder() {
    }
    RequestBuilder.buildAuths = function (auths) {
        var _a, _b, _c, _d;
        if (!auths) {
            return [];
        }
        if (!auths.length) {
            auths = [auths];
        }
        auths = auths;
        for (var _i = 0, auths_1 = auths; _i < auths_1.length; _i++) {
            var authRequest = auths_1[_i];
            if (authRequest.isAnon)
                throw new Error("isAnon not supported yet");
            if (typeof authRequest.authType === undefined) {
                throw new Error("you must provide a authType");
            }
            authRequest.isAnon = false;
            authRequest.isOptional = (_a = authRequest.isOptional) !== null && _a !== void 0 ? _a : false;
            authRequest.userId = (_b = authRequest.userId) !== null && _b !== void 0 ? _b : "0";
            authRequest.extraData = (_c = authRequest.extraData) !== null && _c !== void 0 ? _c : "";
            if (authRequest.userId === "0") {
                authRequest.isSelectableByUser = (_d = authRequest.isSelectableByUser) !== null && _d !== void 0 ? _d : true;
            }
            else {
                authRequest.isSelectableByUser = false;
            }
            if (authRequest.authType === AuthType.VAULT) {
                authRequest.isSelectableByUser = false;
                authRequest.userId = "0";
            }
            if (authRequest.userId !== "0") {
                authRequest.userId = toSismoIdentifier(authRequest.userId, authRequest.authType);
            }
        }
        return auths;
    };
    RequestBuilder.buildClaims = function (claims) {
        var _a, _b, _c, _d;
        if (!claims) {
            return [];
        }
        if (claims === null || claims === void 0 ? void 0 : claims.groupId) {
            claims = [claims];
        }
        claims = claims;
        for (var _i = 0, claims_1 = claims; _i < claims_1.length; _i++) {
            var claimRequest = claims_1[_i];
            if (typeof claimRequest.claimType === undefined) {
                throw new Error("you must provide a claimType");
            }
            if (typeof claimRequest.groupId === undefined) {
                throw new Error("you must provide a groupId");
            }
            claimRequest.claimType = (_a = claimRequest.claimType) !== null && _a !== void 0 ? _a : ClaimType.GTE;
            claimRequest.extraData = (_b = claimRequest.extraData) !== null && _b !== void 0 ? _b : '';
            claimRequest.groupTimestamp = (_c = claimRequest.groupTimestamp) !== null && _c !== void 0 ? _c : "latest";
            claimRequest.value = (_d = claimRequest.value) !== null && _d !== void 0 ? _d : 1;
        }
        return claims;
    };
    RequestBuilder.buildSignature = function (signature) {
        var _a, _b;
        if (!signature) {
            return null;
        }
        if (typeof signature.message === undefined) {
            throw new Error("you must provide a message");
        }
        signature.isSelectableByUser = (_a = signature.isSelectableByUser) !== null && _a !== void 0 ? _a : false;
        signature.extraData = (_b = signature.extraData) !== null && _b !== void 0 ? _b : "";
        return signature;
    };
    return RequestBuilder;
}());

var getGroupFromIdQuery = "\n  query getGroup($id: ID!) {\n    group(id: $id) {\n      id\n      name\n      description\n      specs\n      generationFrequency\n      snapshots {\n        timestamp\n        dataUrl\n      }\n    }\n  }\n";
var getGroupFromNameQuery = "\n  query getGroup($name: String!) {\n    group(name: $name) {\n      id\n      name\n      description\n      specs\n      generationFrequency\n      snapshots {\n        timestamp\n        dataUrl\n      }\n    }\n  }\n";

var ApiFetcher = /** @class */ (function () {
    function ApiFetcher(url) {
        this._url = url;
    }
    ApiFetcher.prototype.getWithQuery = function (opts) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(this._url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                query: opts.query,
                                variables: opts.variables,
                            }),
                        })
                            .then(function (res) { return res.json(); })
                            .then(function (res) { return res.data; })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return ApiFetcher;
}());

var sismoApiUrls = {
    staging: "https://api.staging.zikies.io",
    testnets: "https://api.testnets.sismo.io",
    prod: "https://api.sismo.io",
};

var Sdk = /** @class */ (function () {
    function Sdk(sismoApiUrl) {
        this._apiFetcher = new ApiFetcher(sismoApiUrl !== null && sismoApiUrl !== void 0 ? sismoApiUrl : sismoApiUrls.prod);
    }
    Sdk.prototype.getGroup = function (_a) {
        var id = _a.id, name = _a.name, timestamp = _a.timestamp;
        return __awaiter(this, void 0, void 0, function () {
            var group, _b, dataUrl, snapshot, data;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!id && !name) {
                            throw new Error("Either id or name must be provided for the group. You can view all groups at https://factory.sismo.io/groups-explorer.");
                        }
                        if (!id) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._apiFetcher.getWithQuery({
                                query: getGroupFromIdQuery,
                                variables: { id: id },
                            })];
                    case 1:
                        _b = (_c.sent()).group;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this._apiFetcher.getWithQuery({
                            query: getGroupFromNameQuery,
                            variables: { name: name },
                        })];
                    case 3:
                        _b = (_c.sent()).group;
                        _c.label = 4;
                    case 4:
                        group = _b;
                        if (timestamp) {
                            snapshot = group.snapshots.filter(function (s) { return s.timestamp === timestamp; })[0];
                            (dataUrl = snapshot.dataUrl);
                            if (!snapshot) {
                                (dataUrl = group.snapshots[0].dataUrl);
                            }
                        }
                        else {
                            (dataUrl = group.snapshots[0].dataUrl);
                        }
                        return [4 /*yield*/, fetch(dataUrl).then(function (res) { return res.json(); })];
                    case 5:
                        data = _c.sent();
                        return [2 /*return*/, __assign(__assign({}, group), { data: data })];
                }
            });
        });
    };
    return Sdk;
}());

var PROD_VAULT_APP_BASE_URL = "https://vault-beta.sismo.io";
var DEV_VAULT_APP_BASE_URL = "https://dev.vault-beta.sismo.io";

var unCompressResponse = function (data) { return ungzip(toUint8Array(data), { to: 'string' }); };

var toBytes16 = function (data) {
    if (isHex(data))
        return pad(data, { size: 16 });
    else
        return sliceHex(keccak256(hexlify(data)), 0, 16);
};
var toBytes32 = function (data) {
    return pad(hexlify(data), { size: 32, dir: 'right' });
};
var toBytes = function (data) {
    return toHex(toBytes$1(data));
};
var hexlify = function (data) {
    return isHex(data) ? data : toHex(data);
};
var formatResponseToEncode = function (sismoConnectResponse) {
    var _a, _b, _c;
    return {
        appId: toBytes16(sismoConnectResponse.appId),
        namespace: toBytes16((_a = sismoConnectResponse === null || sismoConnectResponse === void 0 ? void 0 : sismoConnectResponse.namespace) !== null && _a !== void 0 ? _a : "main"),
        version: toBytes32(sismoConnectResponse.version),
        signedMessage: (_b = sismoConnectResponse.signedMessage) !== null && _b !== void 0 ? _b : toBytes("0x0000000000000000000000000000000000000000000000000000000000000000"),
        proofs: (_c = sismoConnectResponse.proofs) === null || _c === void 0 ? void 0 : _c.map(function (proof) {
            var _a, _b, _c, _d, _e, _f;
            return {
                claims: (_b = (_a = proof.claims) === null || _a === void 0 ? void 0 : _a.map(function (claim) {
                    var _a, _b, _c, _d, _e, _f, _g;
                    return {
                        groupId: toBytes16((_a = claim.groupId) !== null && _a !== void 0 ? _a : "0x00"),
                        groupTimestamp: !((_b = proof === null || proof === void 0 ? void 0 : proof.claims[0]) === null || _b === void 0 ? void 0 : _b.groupTimestamp) || ((_c = proof === null || proof === void 0 ? void 0 : proof.claims[0]) === null || _c === void 0 ? void 0 : _c.groupTimestamp) === "latest" ? pad(hexlify("latest"), { size: 16, dir: "right" }) : toBytes((_d = proof === null || proof === void 0 ? void 0 : proof.claims[0]) === null || _d === void 0 ? void 0 : _d.groupTimestamp),
                        claimType: claim.claimType,
                        isSelectableByUser: (_e = claim === null || claim === void 0 ? void 0 : claim.isSelectableByUser) !== null && _e !== void 0 ? _e : false,
                        value: BigInt((_f = claim.value) !== null && _f !== void 0 ? _f : 1),
                        extraData: toBytes((_g = claim.extraData) !== null && _g !== void 0 ? _g : "")
                    };
                })) !== null && _b !== void 0 ? _b : [],
                auths: (_d = (_c = proof.auths) === null || _c === void 0 ? void 0 : _c.map(function (auth) {
                    var _a, _b, _c, _d;
                    return {
                        authType: auth === null || auth === void 0 ? void 0 : auth.authType,
                        isAnon: (_a = auth === null || auth === void 0 ? void 0 : auth.isAnon) !== null && _a !== void 0 ? _a : false,
                        isSelectableByUser: (_b = auth === null || auth === void 0 ? void 0 : auth.isSelectableByUser) !== null && _b !== void 0 ? _b : false,
                        userId: BigInt((_c = auth === null || auth === void 0 ? void 0 : auth.userId) !== null && _c !== void 0 ? _c : 0),
                        extraData: toBytes((_d = auth.extraData) !== null && _d !== void 0 ? _d : ""),
                    };
                })) !== null && _d !== void 0 ? _d : [],
                proofData: proof.proofData,
                provingScheme: toBytes32((_e = proof === null || proof === void 0 ? void 0 : proof.provingScheme) !== null && _e !== void 0 ? _e : "hydra-s2.1"),
                extraData: toBytes((_f = proof.extraData) !== null && _f !== void 0 ? _f : "")
            };
        }),
    };
};
var toSismoConnectResponseBytes = function (sismoConnectResponse) {
    if (!sismoConnectResponse)
        return null;
    return encodeAbiParameters([
        {
            "components": [
                {
                    "internalType": "bytes16",
                    "name": "appId",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "namespace",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes32",
                    "name": "version",
                    "type": "bytes32"
                },
                {
                    "internalType": "bytes",
                    "name": "signedMessage",
                    "type": "bytes"
                },
                {
                    "components": [
                        {
                            "components": [
                                {
                                    "internalType": "enum AuthType",
                                    "name": "authType",
                                    "type": "uint8"
                                },
                                {
                                    "internalType": "bool",
                                    "name": "isAnon",
                                    "type": "bool"
                                },
                                {
                                    "internalType": "bool",
                                    "name": "isSelectableByUser",
                                    "type": "bool"
                                },
                                {
                                    "internalType": "uint256",
                                    "name": "userId",
                                    "type": "uint256"
                                },
                                {
                                    "internalType": "bytes",
                                    "name": "extraData",
                                    "type": "bytes"
                                }
                            ],
                            "internalType": "struct Auth[]",
                            "name": "auths",
                            "type": "tuple[]"
                        },
                        {
                            "components": [
                                {
                                    "internalType": "enum ClaimType",
                                    "name": "claimType",
                                    "type": "uint8"
                                },
                                {
                                    "internalType": "bytes16",
                                    "name": "groupId",
                                    "type": "bytes16"
                                },
                                {
                                    "internalType": "bytes16",
                                    "name": "groupTimestamp",
                                    "type": "bytes16"
                                },
                                {
                                    "internalType": "bool",
                                    "name": "isSelectableByUser",
                                    "type": "bool"
                                },
                                {
                                    "internalType": "uint256",
                                    "name": "value",
                                    "type": "uint256"
                                },
                                {
                                    "internalType": "bytes",
                                    "name": "extraData",
                                    "type": "bytes"
                                }
                            ],
                            "internalType": "struct Claim[]",
                            "name": "claims",
                            "type": "tuple[]"
                        },
                        {
                            "internalType": "bytes32",
                            "name": "provingScheme",
                            "type": "bytes32"
                        },
                        {
                            "internalType": "bytes",
                            "name": "proofData",
                            "type": "bytes"
                        },
                        {
                            "internalType": "bytes",
                            "name": "extraData",
                            "type": "bytes"
                        }
                    ],
                    "internalType": "struct SismoConnectProof[]",
                    "name": "proofs",
                    "type": "tuple[]"
                }
            ],
            "internalType": "struct SismoConnectResponse",
            "name": "response",
            "type": "tuple"
        }
    ], [
        formatResponseToEncode(sismoConnectResponse)
    ]);
};

var SismoConnect = function (config) {
    return new SismoConnectClient(config);
};
var SismoConnectClient = /** @class */ (function () {
    function SismoConnectClient(_a) {
        var appId = _a.appId, devMode = _a.devMode, vaultAppBaseUrl = _a.vaultAppBaseUrl, sismoApiUrl = _a.sismoApiUrl;
        var _this = this;
        var _b;
        this.request = function (_a) {
            var claims = _a.claims, claim = _a.claim, auths = _a.auths, auth = _a.auth, signature = _a.signature, namespace = _a.namespace, callbackPath = _a.callbackPath, callbackUrl = _a.callbackUrl;
            if (!window)
                throw new Error("requestProof is not available outside of a browser");
            if (!callbackUrl) {
                callbackUrl = window.location.origin + window.location.pathname;
            }
            var url = _this.getRequestLink({
                claims: claims,
                claim: claim,
                auths: auths,
                auth: auth,
                signature: signature,
                namespace: namespace,
                callbackPath: callbackPath,
                callbackUrl: callbackUrl
            });
            window.location.href = encodeURI(url);
        };
        this.getRequestLink = function (_a) {
            var claims = _a.claims, claim = _a.claim, auths = _a.auths, auth = _a.auth, signature = _a.signature, namespace = _a.namespace, callbackPath = _a.callbackPath, callbackUrl = _a.callbackUrl;
            if (!claims && !auths && !signature && !claim && !auth) {
                throw new Error("claims or auths or signature is required");
            }
            if (auths && auth) {
                throw new Error("You can't use both auth and auths");
            }
            if (claims && claim) {
                throw new Error("You can't use both claim and claims");
            }
            var url = "".concat(_this._vaultAppBaseUrl, "/connect?version=").concat(SISMO_CONNECT_VERSION, "&appId=").concat(_this._appId);
            if (claims) {
                url += "&claims=".concat(JSON.stringify(RequestBuilder.buildClaims(claims)));
            }
            if (claim) {
                url += "&claims=".concat(JSON.stringify(RequestBuilder.buildClaims(claim)));
            }
            if (auths) {
                url += "&auths=".concat(JSON.stringify(RequestBuilder.buildAuths(auths)));
            }
            if (auth) {
                url += "&auths=".concat(JSON.stringify(RequestBuilder.buildAuths(auth)));
            }
            if (signature) {
                signature = RequestBuilder.buildSignature(signature);
                url += "&signature=".concat(JSON.stringify(signature));
            }
            if (_this._devConfig) {
                url += "&devConfig=".concat(JSON.stringify(_this._devConfig));
            }
            if (callbackPath) {
                url += "&callbackPath=".concat(callbackPath);
            }
            if (namespace) {
                url += "&namespace=".concat(namespace);
            }
            if (callbackUrl) {
                url += "&callbackUrl=".concat(callbackUrl);
            }
            url += "&compressed=true";
            return url;
        };
        this.getResponse = function () {
            if (!window)
                throw new Error("getResponse is not available outside of a browser");
            var url = new URL(window.location.href);
            if (url.searchParams.has('sismoConnectResponseCompressed')) {
                var compressedResponse = url.searchParams.get('sismoConnectResponseCompressed');
                var uncompressedResponse = unCompressResponse(compressedResponse);
                return JSON.parse(uncompressedResponse);
            }
            return null;
        };
        this.getResponseBytes = function () {
            if (!window)
                throw new Error("getResponse is not available outside of a browser");
            var url = new URL(window.location.href);
            if (url.searchParams.has('sismoConnectResponseCompressed')) {
                var compressedResponse = url.searchParams.get('sismoConnectResponseCompressed');
                var uncompressedResponse = unCompressResponse(compressedResponse);
                var sismoConnectResponse = JSON.parse(uncompressedResponse);
                return toSismoConnectResponseBytes(sismoConnectResponse);
            }
            return null;
        };
        this._appId = appId;
        this._devModeEnabled = (_b = devMode === null || devMode === void 0 ? void 0 : devMode.enabled) !== null && _b !== void 0 ? _b : false;
        this._vaultAppBaseUrl =
            vaultAppBaseUrl !== null && vaultAppBaseUrl !== void 0 ? vaultAppBaseUrl : (this._devModeEnabled ? DEV_VAULT_APP_BASE_URL : PROD_VAULT_APP_BASE_URL);
        if (this._devModeEnabled) {
            console.warn('sismoConnect launch in DevMode! Never use this mode in production!');
        }
        if (devMode === null || devMode === void 0 ? void 0 : devMode.devGroups) {
            console.warn("These Eligibles addresses will be used in data groups. Never use this in production!");
        }
        this._devConfig = devMode;
        this._sdk = new Sdk(sismoApiUrl);
    }
    SismoConnectClient.prototype.getGroup = function (_a) {
        var id = _a.id, name = _a.name, timestamp = _a.timestamp;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, this._sdk.getGroup({ id: id, name: name, timestamp: timestamp })];
            });
        });
    };
    return SismoConnectClient;
}());

var useSismoConnect = function (_a) {
    var config = _a.config;
    var _b = useState(null), response = _b[0], setResponse = _b[1];
    var _c = useState(null), responseBytes = _c[0], setResponseBytes = _c[1];
    var sismoConnect = useMemo(function () {
        return SismoConnect(config);
    }, [config]);
    useEffect(function () {
        var sismoConnectResponse = sismoConnect.getResponse();
        var sismoConnectResponseBytes = sismoConnect.getResponseBytes();
        if (sismoConnectResponse)
            setResponse(sismoConnectResponse);
        if (sismoConnectResponseBytes)
            setResponseBytes(sismoConnectResponseBytes);
    }, []);
    return {
        response: response,
        responseBytes: responseBytes,
        sismoConnect: sismoConnect
    };
};

var SismoConnectButton = function (_a) {
    var appId = _a.appId, claims = _a.claims, claim = _a.claim, auths = _a.auths, auth = _a.auth, signature = _a.signature, onResponse = _a.onResponse, onResponseBytes = _a.onResponseBytes, config = _a.config, 
    // [Deprecated]
    callbackPath = _a.callbackPath, callbackUrl = _a.callbackUrl, namespace = _a.namespace, 
    // [Deprecated]
    verifying = _a.verifying, text = _a.text, loading = _a.loading, overrideStyle = _a.overrideStyle;
    if (!appId && !config) {
        throw new Error("please add at least one appId or a config props in ZkConnectButton");
    }
    if (appId && config && appId !== config.appId) {
        throw new Error("the 'appId' props of your ZkConnectButton is different from the 'appId' in your configuration. Please add the same 'appId' props as in your configuration or remove the 'appId' prop");
    }
    if (!claims && !auths && !signature && !claim && !auth) {
        throw new Error("Please specify at least one claimRequest or authRequest or signatureRequest");
    }
    if (claim && claims) {
        throw new Error("You can't use both claim and claims props");
    }
    if (auth && auths) {
        throw new Error("You can't use both auth and auths props");
    }
    var _b = useSismoConnect({
        config: config || {
            appId: appId
        }
    }), sismoConnect = _b.sismoConnect, response = _b.response, responseBytes = _b.responseBytes;
    useEffect(function () {
        if (!response || !onResponse)
            return;
        onResponse(response);
    }, [response]);
    useEffect(function () {
        if (!responseBytes || !onResponseBytes)
            return;
        onResponseBytes(responseBytes);
    }, [responseBytes]);
    return (React.createElement("button", { className: "sismoConnectButton", style: __assign$1({ cursor: verifying || loading ? "default" : "cursor" }, overrideStyle), onClick: function () {
            if (verifying || loading)
                return;
            sismoConnect.request({
                claims: claims,
                auths: auths,
                claim: claim,
                auth: auth,
                signature: signature,
                callbackPath: callbackPath,
                callbackUrl: callbackUrl,
                namespace: namespace
            });
        } },
        verifying || loading ?
            React.createElement(Loader, null)
            :
                React.createElement("div", { className: "sismoConnectButtonLogo" },
                    React.createElement(Logo, null)),
        React.createElement("div", { className: "sismoConnectButtonText" }, text || "Sign in with Sismo")));
};

export { ApiFetcher, AuthType, ClaimType, DEV_VAULT_APP_BASE_URL, PROD_VAULT_APP_BASE_URL, ProvingScheme, RequestBuilder, SISMO_CONNECT_VERSION, Sdk, SismoConnect, SismoConnectButton, SismoConnectClient, SismoConnectVerifiedResult, getGroupFromIdQuery, getGroupFromNameQuery, resolveSismoIdentifier, sismoApiUrls, toSismoIdentifier, useSismoConnect };
//# sourceMappingURL=index.js.map
